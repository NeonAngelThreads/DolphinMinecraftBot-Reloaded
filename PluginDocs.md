### **[<- Back to README.md](README.md)**
# Customized Plugin Developing Guide
In this section, you will learn:
- **1. Plugin Jar Structures**
- **2. To Create a Simple Plugin**
- **3. Understand Plugin Lifecycles**  


## 1. Plugin Structure
  Plugin jar files are supposed to be contained the plugin manifest file `plugin.json` inside the root of jar file.  
  **Jar file structure:**  
  ````text 
    MyPlugin.jar
      ├─plugin.json
      └─org
        └─me
          └─plugin
            └─MyPlugin.java
   ````
  Manifest file `plugin.json` is aiming to specify the **entry class** of plugin, plugin name and version.  
  **An example for configuring the `plugin.json`:**
  ````json
   {
      "entry": "org.me.plugin.MyPlugin",
      "name": "MyPlugin",
      "version": "1.0.0"
   }
  ````
  1. **How Entry Class Being Located**:   
    When loading a plugin, DolphinBot will locate the target entry class defined in `plugin.json`, if `plugin.json` not existing, 
    it will scan all classes that extends `AbstractPlugin`, if class not found, it will skip and ignore this plugin.  

## 2. Build A Simple Plugin
  Before start, you need to add DolphinAPI dependency. There are following steps:  
  - Download `DolphinBot-<NEWEST-VERSION>-RELEASE.jar` jar archive.  
  - Add this archive as dependency to your project.     

  Every single plugin entry class needs to extend the `AbstractPlugin` class:

   ````java
    package org.angellock.impl.extensions;

    import org.angellock.impl.AbstractRobot;
    import org.angellock.impl.events.handlers.LoginHandler;
    import org.angellock.impl.providers.AbstractPlugin;
    
    public class ExamplePlugin extends AbstractPlugin {
        @Override
        public String getPluginName() {
            return "My First Plugin";
        }
    
        @Override
        public String getVersion() {
            return "1.0.0";
        }
    
        @Override
        public String getDescription() {
            return "Hello DolphinBot";
        }
    
        @Override
        public void onDisable() {
            getLogger().info("Disabling {} - {}", this.getName(), getVersion());
            //Disable Message
        }
    
        @Override
        public void onLoad() {
            getLogger().info("Loading {} - {}", this.getName(), getVersion());
            // Loading Plugin Message
        }
    
        @Override
        public void onEnable(AbstractRobot entityBot) {
            getListeners().add(
                    new LoginHandler().addExtraAction((loginPacket) -> {
                        getLogger().info(loginPacket.getCommonPlayerSpawnInfo().getGameMode().name());
                    })
            );
        }
}

   ````
  - You can also refer to the example plugin in folder `/example-plugin/example_plugin` for help, or you can base on this demo plugin as your template to develop your own plugin.  
- After you package your plugin, put the packaged plugin in folder `/plugins` (Global plugin directory).
- If you only want to apply a plugin to a specified bot, put plugin into `/plugin/<Bot Profile Name>` (Automatically
  generated by DolphinBot.)

## 3. Register Event Handlers:

In order to make DolphinAPI more easy-used and scalable, DolphinBot also provides a Bukkit-like Event APIs.

### `@EventHandler` Annotation:

- The `@EventHandler` is aimed mark methods as handleable actions. Whenever `@EventHandler` is declared on methods,
  it will inject the inner method code into `EventDispatcher` by using reflects.  
  `@EventHandler` has an optional parameter, namely handling priority, which is classified by `EventPriority` enum.
  Absent for `EventPriority.NORMAL`.

There are 6 different priority level:

| Event Priority | Description                                     |
|----------------|-------------------------------------------------|
| LOWEST         | Lowest priority, might be ignored by dispatcher |
| LOW            | Low but above lowest                            |
| NORMAL         | Default level, meets normal tasks               |
| HIGH           | Above NORMAL                                    |
| HIGHEST        | Above the HIGH level                            |
| MONITOR        | More than HIGHEST level, may consume more CPU   |

**Examples:**  
Create a class named `MyListener`
by Implementing `IListener` interface, and annotate `@EventHandler` on methods you want to handle.

```java
import org.angellock.impl.events.EventPriority;
import org.angellock.impl.events.IListener;
import org.angellock.impl.events.annotations.EventHandler;
import org.angellock.impl.events.types.PlayerMoveEvent;
import org.angellock.impl.ingame.Player;
import org.angellock.impl.util.math.Position;

public class MyListener implements IListener {
    @EventHandler(EventPriority.HIGHEST)
    public void onPlayerMove(PlayerMoveEvent event) {
        Player player = event.getPlayer();
        System.out.println("Warning! the player " + player.getName() + " is moving!");
    }
    
    @EventHandler(EventPriority.LOW)
    public void onPlayerChat(PlayerChatEvent event){
        Player sender = event.getSender();
        String msg = event.getMessage();
        System.out.println("In-Game message: "+sender.getName()+ " has sent "+msg);
    }
}
```

After that, you need to register the listener class `MyListener` you just create.  
Added below code to `onEnable()` method in `ExamplePlugin`:

```java
...
@Override
public void onEnable(AbstractRobot entityBot) {
    registerEvent(new MyListener());
}
```

Alternately you can put `@EventHandler` methods into `ExamplePlugin` class instead of creating new listener class,
The only thing you need to do is make `ExamplePlugin` to also implement the `IListener` interface:  
**Here is Example:**

```java
import org.angellock.impl.events.IListener;
import org.angellock.impl.events.annotations.EventHandler;
import org.angellock.impl.events.types.EntityEmergedEvent;
import org.angellock.impl.providers.AbstractPlugin;
import org.geysermc.mcprotocollib.protocol.data.game.entity.type.EntityType;

public class ExamplePlugin extends AbstractPlugin implements IListener {
    @Override
    public void onEnable(AbstractRobot entityBot) {
        registerEvent(this); // Because plugin class implemented IListener, so it is also a Listener Type.
    }

    @EventHandler // None Parameter for default event priority.
    public onTestEvent(EntityEmergedEvent event) {
        EntityType entityType = event.getEntity();
        System.out.println("An Entity emerges: " + entityType.name());
    }

    @Override
    public String getPluginName() {
        return "My First Plugin";
    }

    @Override
    public String getVersion() {
        return "1.0.0";
    }

    @Override
    public String getDescription() {
        return "Hello DolphinBot";
    }

    @Override
    public void onDisable() {
        getLogger().info("Disabling {} - {}", this.getName(), getVersion());
        //Disable Message
    }

    @Override
    public void onLoad() {
        getLogger().info("Loading {} - {}", this.getName(), getVersion());
        // Loading Plugin Message
    }
}
```

### Dolphin's Event Listeners

- Available Event Listeners:

  | Event Listener     | Only Triggered When                                      |
    |--------------------|----------------------------------------------------------|
  | PlayerMoveEvent    | Triggered when a nearby player moves                     |
  | EntityEmergedEvent | A entity generates, player emerged, or projectile thrown |
  | PlayerChatEvent    | When a player send a in-game message.                    |
- Note That:
    - Every single handling method should annotate with `@EventHandler`.
    - All handling method should be public.
    - Remember to register the all listener classes.

## 3. Deep Understand DolphinAPIs:  
- ### 1. Listeners and PacketEvents:  
- In above plugin code, at `onEnable()` method, we used `getListeners()` method to get the collection of packet listeners in this plugin.  
    
   ````java
    @Override
    public void onEnable(AbstractRobot entityBot) {
        getListeners().add(
                new LoginHandler().addExtraAction((loginPacket) -> {
                    getLogger().info(loginPacket.getCommonPlayerSpawnInfo().getGameMode());
                })
        );
    }
   ````
   Above code implements an informant that will print current gamemode info once the bot join to or be redirected to a server.  
   **Code Explanation:**  
   `getListeners()` returns an iterable list of `AbstractEventProcessor`, allows you to use `add()` to register various packet handlers.  
   Packet handlers includes `LoginHandler`, `SystemChatHandler`, `PlayerLogInfo.UpdateHandler`, `PlayerLogInfo.RemoveHander`, `JoinedGameHandler` and so on.  
   - **Customize Handlers:**  
    Excepting implemented handlers, you can make custom packet handlers by **extending** `AbstractEventProcessor` class:  
    For example, if you want to create a custom handler that listens and handles `ClientboundPlayerChatPacket`, you should **extend**
    the `AbstractEventProcessor` class:
   ````java
    package org.angellock.impl.extensions;
    
    import org.angellock.impl.events.AbstractEventProcessor;
    import org.geysermc.mcprotocollib.network.packet.Packet;
    import org.geysermc.mcprotocollib.protocol.packet.ingame.clientbound.ClientboundPlayerChatPacket;
    
    public class MyHandler extends AbstractEventProcessor<ClientboundPlayerChatPacket> { // specifying target packet type.
        @Override
        protected boolean isTargetPacket(Packet packet) {
            return (packet instanceof ClientboundPlayerChatPacket); // filtering out other packet type.
        }
    }

   ````
   After that, you can use your packet handler ``MyHandler`` class to register your custom listener at your custom plugin.
  By using `.addExtraAction()`, you can add your wanted action towards `MyHandler`. Finally, add it to the global listener.  
   ````java
    import org.angellock.impl.extensions.examples.MyHandler;

    @Override
    public void onEnable(AbstractRobot entityBot) {
        getListeners().add(
                new MyHandler().addExtraAction((playerChatPacket) -> {
                    getLogger().info(playerChatPacket.getContent()); // Example Action.
                })
        );
    }
   ````

- ### 2. Commands System:
- Command system implements an advanced and easy-used CommandAPI, it encapsulates varied base classes
  including `CommandSerializer`, `CommandBuilder` and so on, allowing you to register custom commands on your plugin
  with several simple codes.  
    DolphinCommandAPI adopts `!` or `！` (namely English exclamation & Chinese exclamation) character as prefix of command for
  in-game command executing.  
    To register a custom command, you need to use `getCommands().register(Command)`.  
    And `.register()` method receives a `Command` object
  instance, a `Command` instance should be constructed by the `CommandBuilder`:
    ```java
  Command command = new CommandBuilder().withName('commandName').build((response) -> {});
  ```
  `CommandBuilder` has multiple optional chaining methods other from `.withName()`, including:
    - `.withName(String)`: Specify command name for executing.
    - `.allowedUsers(String...users)`: Specify only who can use this command, absent for allowing all players by default.  
    - `.build()`: At the end, call `.build()` to construct command. It returns a `Command` object.  
    For example, if you want to register a command that could be triggered by chat message `!test`, only for player `PlayerName` uses, 
    and prints sub-commands you passed, the code looks like this:
  ```java
    @Override
    public void onEnable(AbstractRobot abstractRobot) {
        getCommands().register(new CommandBuilder().withName("test").allowedUsers("PlayerName").build((response) -> {
            String[] subCommand = response.getCommandList(); // get command list contains main-command and sub-command.
            
            getLogger().info(Arrays.toString(subCommand));
        }));
     }
  ```
  The `response` parameter inside the lambda expression is an object of `CommandResponse`, it wrapped command meta-infos and call-infos, including sub-command list,
  and command sender.  
    **An Example of getting command-sender and command list:**
    ```java
     @Override
     public void onEnable(AbstractRobot abstractRobot) {
        getCommands().register(new CommandBuilder().withName("uid").allowedUsers("Melibertan").build((response) -> {
            String[] subCommand = response.getCommandList(); // get command list contains main-command and sub-command.
            String commandSender = response.getSender(); // get player who have sent this command.
        }));
     }
    ```
    For each plugin has individual command system, and every command system is base on `SystemChatPacket` and `PlayerChatPacket` listening.  
    The command sender and command list is serialized by `CommandSerializer`.
- ### 3. Message Manager:
    In-game chat messages sends is managed by `MessageManager`.  
    For each bot individual has a message manager. 
## Player Events:
DolphinAPI also implemented player event system, allowing you to detect and predict online players on server.  
   - `Player` class:  
    Every `Player` object represents an individual player in the scope of server stimulation distance.  
    It provides position information. position data is automatically updated by the robot instance.  
    **An Example of Player Event Use:**  
        Below code implements that auto capture position of a moving player.  
        ```java
        import org.angellock.impl.providers.AbstractPlugin;
        public class TestPlayerPlugin extends AbstractPlugin {
            @Override
            public void onEnable(AbstractRobot abstractRobot) {
                getListeners().add(new EntityMovePacket().addExtraAction((movepacket)->{
                    getLogger().info("Moving player position: "+abstractRobot.getOnlinePlayers().get(movepacket.getEntityId()).getPosition());
                }));
            }
     
            @Override
            public String getPluginName() {
                return "TestPlugin";
            }
            @Override
            public String getVersion() {
                return "1.0.0";
            }
            @Override
            public String getDescription() {
                return "TestPlugin";
            }
            @Override
            public void onDisable() {
                getLogger().info("disabling plugin!");
            }
        }
        ```
        If you want to detect the moving player distance from your bot, you can use `player.getPosition().getDistance(bot.getPosition())`:  
        **Here is Example:**  
        This code presents that if a player is 7 blocks close to your bot, bot will auto quit the game.
        ````java
        import org.angellock.impl.ingame.IPlayer;
        ...
            @Override
            public void onEnable(AbstractRobot abstractRobot) {
                IPlayer target = abstractRobot.getOnlinePlayers().get(movepacket.getEntityId());
                if(target != null){
                    if(target.getPosition().getDistance(abstractRobot.getPosition()) < 7){
                        abstractRobot.getSession().disconnect("Test");
                    }
                }
            }
        ````
## Unicode String Helper
Dolphin bot provides `UStringHelper` class to help you to convert the common text (including digits) into other Unicode characters,
 which can obfuscate server to bypass key word censoring.  
**Example:**
````java
String message = "TestText123 789";
String stringUUID = UStringHelper.forceUnicode(message);
````
    
## 4. How a Plugin Works
  1. **Base Plugin Events**:  
   Every single plugin exists in form of a jar file managed by `PluginManager`. The `PluginManager` is used to enable
   and register plugins or disable them.  
   Each plugin has 3 base simple loading handlers:
     1. **The `onLoad()` Method.**
     2. **The `onRegister()` Method.**
     3. **The `onDisable()` Method.**  
     - The differences between method `onLoad()` and `onRegister()`:  
       `onLoad()` method is called only when plugin internal classes and resources is being loading.  
       `onRegister()` method is called only when plugin classes loads was completed and register its wrapped listeners.
  2. **Lifecycle of a Plugin** :  
     When bot initialized, it will scan for all plugins in the plugin folder, and then fetches **entry class**, at this phase, `onLoad()` method will be called.  
     Once a bot pre-enter to a server, `PluginLoader` will load all registered listeners of target plugins as `IActions` 
     listener, after that, 
     `PluginManager` will register them as global plugins, at this phase, `onEnable()` method will be called.